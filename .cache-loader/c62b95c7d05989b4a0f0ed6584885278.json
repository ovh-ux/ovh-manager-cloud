{"remainingRequest":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js??ref--11-1!/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/addEdit/cloud-project-compute-infrastructure-virtualMachine-addEdit.controller.js","dependencies":[{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/client/app/cloud/project/compute/infrastructure/virtualMachine/addEdit/cloud-project-compute-infrastructure-virtualMachine-addEdit.controller.js","mtime":1539717142008},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/babel-loader/lib/index.js","mtime":1539597349061},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/cache-loader/dist/cjs.js","mtime":1539679504371},{"path":"/Users/jleveugle/Documents/Work/github/ovh-ux/ovh-manager-cloud/node_modules/@ovh-ux/manager-webpack-config/loaders/ui-router-translations.js","mtime":1539950864368}],"contextDependencies":[],"result":["/* eslint-disable no-use-before-define, consistent-return */\n/**\n *  Add Edit VM Controller - Controls the vm creation popover\n *  =========================================================\n *\n *  =README=\n *  This controller makes queries to different API of /cloud and put datas into panelsData object :\n *  {\n *      flavors   : [],\n *      images    : [],\n *      snapshots : [],\n *      sshKeys   : []\n *  }\n *\n *  These arrays are then filtered by types for display.\n * This filters need to be refreshed when some model value change. Because each region has its own\n *  flavor and images and images types have their own flavors.\n *\n *  Note that when model value change, the associated vmInEdition\n * (the VirtualMachine factory object currently in edition) attribute is updated\n *  by finding resource object into panelsData with model id value.\n *\n *  Flavors array contains Resource objects looking like :\n *  {\n *      disk: Number,\n *      groupName: String (transformed after request response - removing 'win-' of windows flavors),\n *      id: String,\n *      name: String,\n *      osType: String,\n *      price: Object (added from /cloud/price api call),\n *      ram: Number,\n *      region: String,\n *      type: String,\n *      typeGeneric: String (transformed after request response, snakeCase of type),\n *      vcpus: Number\n *  }\n *\n *  Images array contains Resource objects looking like :\n *  {\n *      creationDate: String,\n *      distribution: String,\n *      id: String,\n *      minDisk: Number,\n *      name: String,\n *      nameGeneric: String (transformed after request response, snakeCase of image name),\n *      price: Object (setted if windows type and calculated by removing linux flavor price value\n *      of windows flavor price value - same form of price Object returned by flavor api call),\n *      region: String,\n *      status: String,\n *      type: String,\n *      visibility: String\n *  }\n *\n *  TODO : document snapshot and sshKeys if needed\n */\n\n\n// TODO replace ssh.name_ssh.region by ssh.name with new API\n// TODO fix bug with tooltip. If click on tooltip (quickly), popover quits\n// TODO bug delete ssh key\n// TODO restriction between flavor and image archi (see maxime)\n// TODO default vm configuration\n\n\n// les query sont cached... donc impossible de refresh le table!\n\n// lodash in dom\n// gio converter\n// ssh plein de hide?\n// region zone\n// tooltip faite ac quoi ?\n\n\nangular.module('managerApp')\n  .controller('CloudProjectComputeInfrastructureVirtualMachineAddEditCtrl',\n    function CloudProjectComputeInfrastructureVirtualMachineAddEditCtrl(\n      $scope, $stateParams, $q, $filter, $timeout, $translate, CloudMessage, $rootScope,\n      CloudProjectComputeInfrastructureOrchestrator,\n      OvhApiCloudProjectSshKey, OvhApiCloudProjectFlavor, OvhCloudPriceHelper,\n      OvhApiCloudProjectImage, OvhApiCloudProjectRegion, OvhApiCloudProjectSnapshot,\n      OvhApiCloudProjectQuota, OvhApiCloudProjectNetworkPrivate,\n      OvhApiCloudProjectNetworkPrivateSubnet, OvhApiCloudProjectNetworkPublic,\n      RegionService, CloudImageService, CLOUD_FLAVORTYPE_CATEGORY, CLOUD_INSTANCE_CPU_FREQUENCY,\n      CLOUD_FLAVOR_SPECIFIC_IMAGE, OvhApiMe, URLS, REDIRECT_URLS, atInternet,\n      CLOUD_INSTANCE_HAS_GUARANTEED_RESSOURCES, CLOUD_INSTANCE_DEFAULT_FALLBACK, ovhDocUrl,\n      TARGET,\n    ) {\n      const self = this;\n      const orderBy = $filter('orderBy');\n\n      const serviceName = $stateParams.projectId;\n\n      let oldVmName = null;\n\n      self.regionService = RegionService;\n      self.enums = {\n        flavorsTypes: [],\n        imagesTypes: [],\n        zonesTypes: ['public', 'dedicated'],\n      };\n\n      self.toggle = {\n        editDetail: null, // Current open panel\n        editVmName: null, // vm name edition\n        editFlavor: 'categories',\n        flavorDirty: false,\n        accordions: { // accordions toggles\n          flavors: {},\n          images: {},\n          regions: {},\n        },\n      };\n\n      self.order = {\n        by: 'price',\n        reverse: false,\n      };\n\n      self.activeSwitchPageIndex = 0;\n\n      // Loader during Datas of panels requests\n      self.loaders = {\n        launch: false,\n        allCompleted: false,\n        panelsData: {\n          flavors: false,\n          images: false,\n          snapshots: false,\n          regions: false,\n          sshKeys: false,\n        },\n        sshKey: {\n          add: false,\n          remove: false,\n        },\n        privateNetwork: {\n          subnet: {\n            query: false,\n          },\n          query: false,\n        },\n        publicNetwork: {\n          query: false,\n        },\n        urls: false,\n      };\n\n      // Datas of panels\n      self.panelsData = {\n        flavors: [],\n        images: [],\n        snapshots: [],\n        sshKeys: [],\n        privateNetworks: [],\n        publicNetworks: [],\n        subnets: [],\n      };\n\n      // Datas to display\n      self.displayData = {\n        shortGroupName: null,\n        categories: null,\n        flavors: {},\n        images: {},\n        quota: {},\n        sshKeys: [],\n      };\n\n      self.categoriesVmInEditionFlavor = {};\n\n      self.vmInEdition = {\n        networkId: null,\n      };\n\n      self.currentFlavor = null;\n\n      self.vmInEditionParam = null;\n\n      // Model of virtual machine\n      self.model = {\n        name: null,\n        flavorId: null,\n        imageId: null,\n        imageType: null,\n        region: null,\n        zone: null,\n        sshKeyId: null,\n        vmCount: 1,\n        diskType: 'ceph',\n        flex: false,\n      };\n\n\n      // States Store.\n      self.states = {\n        hasVrack: false,\n        hasSetFlavor: false,\n        hasOldFlavors: false,\n      };\n\n      // Contextual Urls Store.\n      self.urls = {\n        vlansGuide: null,\n        vlansApiGuide: null,\n        vrack: REDIRECT_URLS.vRack,\n        guidesSshkeyURL: null,\n      };\n\n      self.recommendedFlavorName = null;\n\n      // SSHKEYS: Add model\n      function initNewSshKey() {\n        self.sshKeyAdd = {\n          serviceName,\n          name: null,\n          publicKey: null,\n        };\n      }\n      initNewSshKey();\n\n      // SSHKEYS: Deleted ID\n      self.sshKeyDeletedId = null;\n\n      // ---\n\n      /*= ===========================================\n    =            Display data section            =\n    ============================================ */\n\n      /*\n    * - All flavors, images, snapshots, sshkeys are bind to a *region*.\n    *   When user change a region, we need to update all items!\n    * - User can't switch from VPS flavor to CPU/RAM flavor and vice versa.\n    * - User can't downgrade a flavor.\n    * - Flavors beginning with \"win-\" are windows-only, and are a copy of linux equivalent.\n    *   We need to show price of linux for windows flavors...\n    */\n\n\n      /**\n     *  To call when region model value change\n     */\n      function recalculateValues() {\n        // get flavor values\n        getDisplayFlavors();\n        recalculateFlavor();\n        // get image values\n        if (self.vmInEdition.flavor && flavorHasSpecificImages(self.vmInEdition.flavor.shortType)) {\n          // filter for a specific flavor\n          showImages(false, self.vmInEdition.flavor);\n        } else {\n          showImages(true);\n        }\n        recalculateImage();\n        // get quota to be displayed\n        getDisplayQuota();\n        // get ssh keys to be displayed\n        getDisplaySshKeys();\n        recalculateSshKey();\n        // recompute vm count\n        recalculateVmCount();\n        // get the recommended flavour if threshold is reached\n        calculateRecommendedFlavour();\n      }\n\n      // TODO: Redo this with categories.\n      function calculateRecommendedFlavour() {\n        if (self.vmInEdition.monitoringData) {\n          let result;\n          const cpuNeedUpgrade = self.vmInEdition.monitoringData.cpu.needUpgrade;\n          const ramNeedUpgrade = self.vmInEdition.monitoringData.mem.needUpgrade;\n\n          if (cpuNeedUpgrade || ramNeedUpgrade) {\n            const currentFlavor = self.vmInEdition.flavor;\n            self.displayData.flavors[self.vmInEdition.flavor.type].forEach((flavor) => {\n              if (!result\n                        && (cpuNeedUpgrade ? flavor.vcpus > currentFlavor.vcpus : true)\n                        && (ramNeedUpgrade ? flavor.ram > currentFlavor.ram : true)) {\n                result = flavor.name;\n              }\n            });\n          }\n\n          if (result) {\n            self.recommendedFlavorName = result;\n          }\n        }\n      }\n\n      function getDisplayFlavors() {\n        // reset flavors data to display\n        self.displayData.flavors = {};\n        self.displayData.categories = [];\n        // recalculate flavors to display\n\n        let originalCategory = null;\n        if (self.originalVm) {\n          const originalFlavor = _.find(self.panelsData.flavors, { id: self.originalVm.flavor.id });\n          if (originalFlavor && self.vmInEdition.status === 'ACTIVE') {\n            originalCategory = getCategoryFromFlavor(originalFlavor.type, true);\n          }\n        }\n        splitFlavorsByCategories(originalCategory);\n      }\n\n      function splitFlavorsByCategories(originalCategory) {\n        angular.forEach(self.enums.flavorsTypes, (flavorType) => {\n          const category = getCategoryFromFlavor(flavorType, true);\n\n          const cleanFlavors = _.filter(self.panelsData.flavors, flavor => _.get(flavor, 'price.price.text'));\n\n          if (category && _.includes(category.types, flavorType)) {\n            const categoryObject = _.find(self.displayData.categories, { category: category.id });\n            if (categoryObject) {\n              categoryObject.flavors = _(categoryObject.flavors).concat(_.filter(cleanFlavors, {\n                type: flavorType,\n                diskType: 'ssd',\n                flex: false,\n                region: self.model.region,\n                osType: self.vmInEdition.image ? self.vmInEdition.image.type : 'linux', // (display linux flavors by default if no image selected)\n              })).value();\n            } else {\n              self.displayData.categories.push({\n                category: category.id,\n                order: category.order,\n                flavors: _.filter(cleanFlavors, {\n                  available: true,\n                  type: flavorType,\n                  diskType: 'ssd',\n                  flex: false,\n                  region: self.model.region,\n                  osType: self.vmInEdition.image ? self.vmInEdition.image.type : 'linux', // (display linux flavors by default if no image selected)\n                }),\n              });\n            }\n          }\n\n          if (category && originalCategory) {\n            const originalCategoryObject = _.find(\n              self.displayData.categories,\n              { category: category.id },\n            );\n            originalCategoryObject.flavors.forEach((flavor) => {\n              _.set(flavor, 'migrationNotAllowed', _.includes(\n                originalCategory.migrationNotAllowed,\n                category.id,\n              ));\n            });\n          }\n        });\n        _.forEach(self.displayData.categories, (category) => {\n          if (_.some(category.flavors, 'isOldFlavor')) {\n            self.states.hasOldFlavors = true;\n          }\n        });\n        self.displayData.categories = _.sortBy(self.displayData.categories, 'order');\n      }\n\n      function getDisplayImages(flavorType) {\n        // reset images data to display\n        self.displayData.images = {};\n        // recalculate images to display\n        angular.forEach(self.enums.imagesTypes, (imageType) => {\n          // display only images types compatibles with the selected flavor\n          if (self.vmInEdition.flavor) {\n            if (!_.find(self.panelsData.flavors, {\n              osType: imageType,\n              groupName: self.vmInEdition.flavor ? self.vmInEdition.flavor.groupName : undefined,\n            })) {\n              self.displayData.images[imageType] = [];\n              return;\n            }\n          } else if (!_.find(self.panelsData.flavors, {\n            osType: imageType,\n          })) {\n            self.displayData.images[imageType] = [];\n            return;\n          }\n          // filter images by type\n          self.displayData.images[imageType] = _.filter(self.panelsData.images, {\n            type: imageType,\n            region: self.model.region,\n            apps: false,\n          });\n\n          // filter GPU\n          if (flavorType === 'g1' || flavorType === 'g2' || flavorType === 'g3') {\n            self.displayData.images[imageType] = _.filter(self.displayData.images[imageType], image => image.type === 'linux' || (flavorType ? _.includes(image.flavorType, flavorType) : true));\n          } else {\n            self.displayData.images[imageType] = _.filter(\n              self.displayData.images[imageType],\n              image => !image.flavorType,\n            );\n          }\n\n\n          if (self.vmInEdition.flavor) {\n            angular.forEach(self.displayData.images[imageType], (image) => {\n              _.set(image, 'disabled', self.vmInEdition.flavor.disk < image.minDisk ? 'NOT_ENOUGH_SPACE' : false);\n            });\n          }\n        });\n\n        self.displayData.apps = _.filter(self.panelsData.images, {\n          region: self.model.region,\n          apps: true,\n        });\n\n        // filter snapshots by type\n        self.displayData.snapshots = _.filter(self.panelsData.snapshots, {\n          region: self.model.region,\n          status: 'active',\n        });\n\n        if (self.vmInEdition.flavor) {\n          angular.forEach(self.displayData.snapshots, (image) => {\n            _.set(image, 'disabled', self.vmInEdition.flavor.disk < image.minDisk ? 'NOT_ENOUGH_SPACE' : false);\n          });\n        }\n      }\n\n      function getDisplayQuota() {\n        // set display quota with chosen region\n        self.displayData.quota = _.find(self.panelsData.quota, { region: self.model.region });\n      }\n\n      function getDisplaySshKeys() {\n        // Add boolean to know if sshKey is available on the selected region\n        self.displayData.sshKeys = _.map(self.panelsData.sshKeys, (sshKey) => {\n          _.set(sshKey, 'availableOnRegion', sshKey.regions\n            && sshKey.regions.length\n            && sshKey.regions.indexOf(self.model.region) > -1);\n          return sshKey;\n        });\n\n        self.displayData.sshKeyAvailables = _.countBy(self.displayData.sshKeys, 'availableOnRegion').true || 0;\n        self.displayData.sshKeyUnavailables = self.displayData.sshKeys.length\n          - self.displayData.sshKeyAvailables;\n      }\n\n      self.projectHasNoSshKeys = function () {\n        return (!self.loaders.panelsData.sshKeys && self.panelsData.sshKeys.length === 0);\n      };\n\n      this.sectionCanBeModifiedInEdition = function (section) {\n        switch (section) {\n          case 'flavors':\n            return !self.vmInEdition.hasChange('images');\n          case 'images':\n            return !self.vmInEdition.hasChange('flavors');\n          default:\n            return null;\n        }\n      };\n\n      /* -----  End of Display data section  ------*/\n\n      /*= ==================================================\n    =            Model recalculation section            =\n    =================================================== */\n\n      function recalculateFlavor() {\n        let mainAssociatedFlavor = _.find(_.flatten(_.map(self.displayData.categories, 'flavors')), {\n          groupName: self.vmInEdition.flavor && self.vmInEdition.flavor.groupName,\n          osType: self.vmInEdition.image ? self.vmInEdition.image.type : 'linux',\n          region: self.model.region,\n        });\n\n        if (!mainAssociatedFlavor) {\n          // Try in old flavor panel\n          mainAssociatedFlavor = _.find(self.panelsData.flavors, {\n            groupName: self.vmInEdition.flavor && self.vmInEdition.flavor.groupName,\n            osType: self.vmInEdition.image ? self.vmInEdition.image.type : 'linux',\n            region: self.model.region,\n          });\n        }\n\n        if (!mainAssociatedFlavor || mainAssociatedFlavor.disabled) {\n          setFallbackFlavor();\n        } else {\n          self.model.flavorId = mainAssociatedFlavor.id;\n          self.vmInEdition.flavor = mainAssociatedFlavor;\n        }\n\n        angular.forEach(CLOUD_FLAVORTYPE_CATEGORY, (category) => {\n          self.categoriesVmInEditionFlavor[category.id] = self.getRealFlavor(\n            self.categoriesVmInEditionFlavor[category.id],\n            category.id,\n          );\n        });\n      }\n\n      function setFallbackFlavor() {\n        const fallbackFlavor = _.find(_.flatten(_.map(self.displayData.categories, 'flavors')), {\n          groupName: CLOUD_INSTANCE_DEFAULT_FALLBACK.flavor,\n          osType: self.vmInEdition.image ? self.vmInEdition.image.type : 'linux',\n          region: self.model.region,\n        });\n        if (fallbackFlavor) {\n          self.model.flavorId = fallbackFlavor.id;\n          self.vmInEdition.flavor = fallbackFlavor;\n        } else {\n          self.model.flavorId = null;\n          self.vmInEdition.flavor = null;\n        }\n      }\n\n      function recalculateImage() {\n        let associatedDisplayImage;\n\n        let associatedImage = _.find(self.panelsData.images, {\n          name: self.vmInEdition.image && self.vmInEdition.image.name,\n          region: self.model.region,\n        });\n\n        if (associatedImage) {\n          associatedDisplayImage = _.find(self.displayData.images, {\n            id: associatedImage.id,\n          });\n          if (!associatedDisplayImage) {\n            associatedDisplayImage = _.find(self.displayData.apps, {\n              id: associatedImage.id,\n            });\n          }\n        }\n\n        if (!associatedImage) {\n          associatedImage = _.find(self.panelsData.snapshots, {\n            name: self.vmInEdition.image && self.vmInEdition.image.name,\n            region: self.model.region,\n          });\n          if (associatedImage) {\n            associatedDisplayImage = _.find(self.displayData.snapshots, {\n              id: associatedImage.id,\n            });\n          }\n        }\n\n        if (!associatedImage || (associatedDisplayImage && associatedDisplayImage.disabled)) {\n          self.model.imageId = null;\n          self.vmInEdition.image = null;\n        } else {\n          self.model.imageId = associatedImage.id;\n          self.vmInEdition.image = associatedImage;\n        }\n      }\n\n      function recalculateSshKey() {\n        const associatedSshKey = _.find(\n          self.panelsData.sshKeys,\n          sshKey => sshKey.id === self.model.sshKeyId && ~sshKey.regions.indexOf(self.model.region),\n        );\n\n        if (!associatedSshKey) {\n          self.model.sshKeyId = null;\n          self.vmInEdition.sshKey = null;\n        } else {\n          self.model.sshKeyId = associatedSshKey.id;\n          self.vmInEdition.sshKey = associatedSshKey;\n        }\n      }\n\n      function recalculateVmCount() {\n        if (self.vmInEdition.status === 'DRAFT') {\n          if (Number.isNaN(self.model.vmCount)) {\n            self.model.vmCount = 1;\n          } else {\n            self.model.vmCount = Math.min(\n              self.getMaximumInstanceCreationCount(),\n              self.model.vmCount,\n            );\n          }\n        }\n      }\n\n      /* -----  End of Model recalculation section  ------*/\n\n\n      // --------- INITIALISATION ---------\n\n\n      function init() {\n        self.vmInEditionParam = CloudProjectComputeInfrastructureOrchestrator.getEditVmParam();\n        CloudProjectComputeInfrastructureOrchestrator.setEditVmParam(null);\n\n        // When it's a new vm, keep changes in sync and when it's a vm in edit\n        // don't sync changes until apply changes\n        const editedVm = CloudProjectComputeInfrastructureOrchestrator.getEditedVm();\n        if (editedVm.status === 'DRAFT') {\n          self.vmInEdition = editedVm;\n        } else {\n          self.originalVm = editedVm;\n          self.vmInEdition = angular.copy(editedVm);\n        }\n\n        initURLs();\n        $q.all({\n          // get flavors, gets the images (for windows image price calculation), get the quotas\n          flavors: self.getFlavors(),\n          regions: self.getRegions(),\n          sshKeys: self.getSshKeys(),\n          hasVrack: CloudProjectComputeInfrastructureOrchestrator.hasVrack(),\n          user: OvhApiMe.v6().get().$promise,\n        }).then((data) => {\n          self.model.name = self.vmInEdition.name;\n          self.model.flavorId = self.vmInEdition.flavor ? self.vmInEdition.flavor.id : null;\n          self.model.imageId = self.vmInEdition.image ? self.vmInEdition.image.id : null;\n          self.model.region = self.vmInEdition.region;\n          self.model.sshKeyId = self.vmInEdition.sshKey ? self.vmInEdition.sshKey.id : null;\n          // dirty hack has new catalog does not support ceph\n          // but changing default to ssd break old code.\n          self.model.diskType = self.catalogVersion() === 'new' ? 'ssd' : self.model.diskType;\n          self.states.hasVrack = data.hasVrack;\n\n          const guides = URLS.guides.vlans[data.user.ovhSubsidiary];\n          if (guides) {\n            self.urls.vlansGuide = guides.roadmap;\n          }\n          recalculateValues();\n          self.fetchPrivateNetworks();\n          self.fetchPublicNetworks();\n        }).then(() => {\n          editWithParam();\n        }).finally(() => {\n          self.loaders.allCompleted = true;\n        });\n\n        // Tab loop into the popover\n        $timeout(() => {\n          const $popover = $('.cloud-vm-popover');\n          $popover.find(':tabbable:first').focus();\n          $popover.on('keydown', (e) => {\n            if (e.keyCode === 9) {\n              if (e.shiftKey) { // shift+tab\n                if ($(e.target).is($popover.find(':tabbable:first'))) {\n                  $popover.find(':tabbable:last').focus();\n                  e.preventDefault();\n                }\n              } else { // tab\n                if ($(e.target).is($popover.find(':tabbable:last'))) { // eslint-disable-line\n                  $popover.find(':tabbable:first').focus();\n                  e.preventDefault();\n                }\n              }\n            }\n          });\n        }, 99);\n\n        $rootScope.$broadcast('highlighed-element.show', `compute,${self.vmInEdition.id}`);\n      }\n\n      function editWithParam() {\n        switch (self.vmInEditionParam) {\n          case 'NAME':\n            self.toggleEditVmName();\n            break;\n          case 'FLAVOR':\n            if (!self.loaders.panelsData.flavors && self.sectionCanBeModifiedInEdition('flavors') && !self.loaders.launch) {\n              $timeout(() => { self.openEditDetail('flavors', 'flavorId', 'type'); }, 500);\n            }\n            break;\n          case 'IMAGE':\n            if (!self.loaders.panelsData.images && self.sectionCanBeModifiedInEdition('images') && !self.loaders.launch) {\n              $timeout(() => { self.openEditDetail('images', 'imageId', 'type'); }, 500);\n            }\n            break;\n          default:\n        }\n      }\n\n      function initURLs() {\n        self.urls.vlansApiGuide = ovhDocUrl.getDocUrl('g2162.public_cloud_et_vrack_-_comment_utiliser_le_vrack_et_les_reseaux_prives_avec_les_instances_public_cloud');\n\n        if (TARGET === 'US') {\n          self.urls.guidesSshkeyURL = URLS.guides.ssh.create.US;\n        } else {\n          self.urls.guidesSshkeyURL = ovhDocUrl.getDocUrl('g1769.creating_ssh_keys');\n        }\n      }\n\n      function getCategoryFromFlavor(flavor, details) {\n        let cat = null;\n        angular.forEach(CLOUD_FLAVORTYPE_CATEGORY, (category) => {\n          if (_.includes(category.types, flavor)) {\n            if (details) {\n              cat = category;\n            } else {\n              cat = category.id;\n            }\n          }\n        });\n        return cat;\n      }\n\n      // Switch page created: INIT THE MAGIC!\n      $scope.$on('responsive.switch.created', (evt, switcher) => {\n        self.switcher = switcher;\n        init();\n      });\n\n      function firstTimeSetFlavor(isFlavorSuggested, flavorId) {\n        if (!self.states.hasSetFlavor) {\n          let realFlavor;\n\n          const flavor = _.find(\n            self.panelsData.flavors,\n            { id: flavorId || self.vmInEdition.flavor.id },\n          );\n\n          if (isFlavorSuggested) {\n            realFlavor = self.getFlavorOfType(flavor, 'ssd', flavor.flex, flavor.region, flavor.osType);\n          }\n\n          if (!realFlavor) {\n            realFlavor = flavor;\n          }\n\n          if (realFlavor && !realFlavor.disabled) {\n            const category = getCategoryFromFlavor(realFlavor.type);\n            if (category) {\n              self.toggle.accordions.flavors = {};\n              self.toggle.accordions.flavors[category] = true;\n              self.categoriesVmInEditionFlavor[category] = realFlavor;\n              self.displayData.shortGroupName = realFlavor.shortGroupName;\n              self.model.diskType = realFlavor.diskType;\n              self.model.flex = realFlavor.flex;\n              self.vmInEdition.flavor = realFlavor;\n            }\n          }\n          self.states.hasSetFlavor = true;\n        }\n      }\n\n      // Open panel if toggle.editDetail is different of editDetail otherwise close this panel\n      self.openEditDetail = function (editDetail) {\n        // reset accordion value to show focus on selected input\n        if (editDetail === 'flavors') {\n          if (self.model.flavorId) {\n            firstTimeSetFlavor(false, self.model.flavorId);\n          } else {\n            self.toggle.accordions.flavors = {};\n          }\n        }\n\n        self.toggle.editDetail = editDetail;\n        self.activeSwitchPageIndex = 1;\n        self.toggle.editFlavor = 'categories';\n\n        // On open: scroll to selected element, and set focus\n        $timeout(() => {\n          if (~['flavors', 'images', 'regions'].indexOf(editDetail)) {\n            const $checkedRadio = $(`input[name=${editDetail}Choice]:checked`);\n            if ($checkedRadio && $checkedRadio.length) {\n              const $checkedRadioCtnr = $checkedRadio.closest(editDetail === 'flavors' ? 'tbody' : '.panel-body');\n              $checkedRadioCtnr.scrollTo($checkedRadio, 200, { offset: -100 });\n              $checkedRadio.closest(':tabbable').focus();\n            }\n          } else {\n            $('.cloud-vm-popover .popover-second-page').find(':tabbable:first').focus();\n          }\n        }, 500);\n      };\n\n      self.backToMenu = function () {\n        self.activeSwitchPageIndex = 0;\n        self.toggle.editDetail = null;\n        self.toggle.editFlavor = 'categories';\n        self.states.hasSetFlavor = false;\n      };\n\n      self.isSwitchMode = function () {\n        return self.switcher.getDisplayMode() === 'switch';\n      };\n\n      // ---\n\n      // --------- VM  CREATION---------\n\n      self.getFormattedFlavorType = function (flavorType) {\n        return _.snakeCase(flavorType);\n      };\n\n      // Returns the remaining number of instances the user can create on a given region.\n      self.getRemainingInstanceQuota = function (region) {\n        let limit = 0; // by default we assume we aren't allowed to create new instances\n        // check quota\n        if (self.panelsData.quota) {\n          const regionQuota = _.find(self.panelsData.quota, { region });\n          if (regionQuota && regionQuota.instance) {\n            // special case: -1 is considered unlimited\n            if (regionQuota.instance.maxInstances === -1) {\n              limit = Infinity;\n            } else {\n              limit = regionQuota.instance.maxInstances - regionQuota.instance.usedInstances;\n            }\n          }\n        }\n        return limit;\n      };\n\n      self.isValid = function () {\n        const vm = $scope.VmAddEditCtrl.vmInEdition;\n        /*\n         * When editing, it's possible that the image is not found because\n         * the snapshot or image has been deleted. If it's the case the user\n         * still must be allowed to make changes to his vm otherwise the vm edition\n         * would be disabled forever (unless he reinstall his vm with a new\n         * image but he would lost all of his preciouuus data ...)\n         */\n        let validImageId = self.model.imageId;\n        if (vm.saveForEdition && self.model.imageId === null) {\n          validImageId = true;\n        }\n        self.sshKeyRequired = vm.status !== 'ACTIVE' && !(vm.image && vm.image.type !== 'linux'); // TODO C SAAAALE\n        return !!(vm.name\n          && vm.flavor\n          && vm.flavor.price\n          && self.model.flavorId\n          && validImageId\n          && self.model.region\n          && (self.model.sshKeyId || !self.sshKeyRequired));\n      };\n\n      self.putPostVM = function () {\n        self.loaders.launch = true;\n        self.backToMenu();\n\n        // POST\n        if (self.vmInEdition.status === 'DRAFT') {\n          /**\n             * Since we're just supporting only one private network,\n             * map the single network ID as a collection member on the future payload.\n             */\n          if (self.vmInEdition.networkId) {\n            self.vmInEdition.networks = [\n              { networkId: self.vmInEdition.networkId },\n              { networkId: _.first(this.panelsData.publicNetworks).id },\n            ];\n          } else {\n            delete self.vmInEdition.networks;\n          }\n\n          /**\n             * Create multiple VMs at once\n             */\n          if (self.model.vmCount > 1) {\n            CloudProjectComputeInfrastructureOrchestrator\n              .saveMultipleNewVms(self.vmInEdition, self.model.vmCount)\n              .then(() => {\n                $rootScope.$broadcast('highlighed-element.hide', `compute,${self.vmInEdition.id}`);\n                CloudProjectComputeInfrastructureOrchestrator.turnOffVmEdition(\n                  false,\n                  self.vmInEdition,\n                );\n                CloudMessage.success($translate.instant('cpcivm_addedit_save_multiple_success'));\n                atInternet.trackOrder({\n                  name: `[INSTANCE]::${self.vmInEdition.flavor.name.replace(/[\\W_]+/g, '')}[${self.vmInEdition.flavor.name}]`,\n                  page: 'iaas::pci-project::compute::infrastructure::order',\n                  priceTaxFree: self.vmInEdition.flavor.price.monthlyPrice.value,\n                  quantity: self.model.vmCount,\n                  orderId: self.vmInEdition.id,\n                });\n              }, (err) => {\n                CloudMessage.error([$translate.instant('cpcivm_addedit_save_multiple_error'), (err.data && err.data.message) || ''].join(' '));\n                self.loaders.launch = false;\n              });\n            /**\n             * Create just one VM\n             */\n          } else {\n            CloudProjectComputeInfrastructureOrchestrator.saveNewVm(self.vmInEdition).then(() => {\n              $rootScope.$broadcast('highlighed-element.hide', `compute,${self.vmInEdition.id}`);\n              CloudProjectComputeInfrastructureOrchestrator.turnOffVmEdition(\n                false,\n                self.vmInEdition,\n              );\n              atInternet.trackOrder({\n                name: `[INSTANCE]::${self.vmInEdition.flavor.name.replace(/[\\W_]+/g, '')}[${self.vmInEdition.flavor.name}]`,\n                page: 'iaas::pci-project::compute::infrastructure::order',\n                priceTaxFree: self.vmInEdition.flavor.price.monthlyPrice.value,\n                orderId: self.vmInEdition.id,\n              });\n            }, (err) => {\n              if (err && err.status === 409) {\n                CloudMessage.error($translate.instant('cpcivm_edit_vm_post_error_overquota'));\n              } else {\n                CloudMessage.error([$translate.instant('cpcivm_edit_vm_post_error'), (err.data && err.data.message) || ''].join(' '));\n              }\n              self.loaders.launch = false;\n            });\n          }\n        } else {\n        // PUT\n          CloudProjectComputeInfrastructureOrchestrator.saveEditedVm(self.vmInEdition).then(() => {\n            $rootScope.$broadcast('highlighed-element.hide', `compute,${self.vmInEdition.id}`);\n            CloudProjectComputeInfrastructureOrchestrator.turnOffVmEdition(false, self.vmInEdition);\n          }, (err) => {\n            if (err && err.status === 409) {\n              CloudMessage.error($translate.instant('cpcivm_edit_vm_post_error_overquota'));\n            } else {\n              angular.forEach(err.errors, (err) => { // eslint-disable-line\n                CloudMessage.error([$translate.instant(`cpcivm_edit_vm_${err.requestName}_error`), err.error.message || ''].join(' '));\n              });\n            }\n            self.loaders.launch = false;\n          });\n        }\n      };\n\n      this.cancelVm = function () {\n        // delete vm if it's a draft\n        if (self.vmInEdition.status === 'DRAFT') {\n          CloudProjectComputeInfrastructureOrchestrator.deleteVm(self.vmInEdition);\n        }\n        $rootScope.$broadcast('highlighed-element.hide', `compute,${self.vmInEdition.id}`);\n        CloudProjectComputeInfrastructureOrchestrator.turnOffVmEdition(true);\n      };\n\n      const closeOnEscapeKey = function (evt) {\n        if (evt.which === 27) {\n          self.cancelVm();\n        }\n        $scope.$apply();\n      };\n\n      $(document).on('keyup', closeOnEscapeKey);\n\n      $scope.$on('$destroy', () => {\n        $(document).off('keyup', closeOnEscapeKey);\n      });\n\n      // --------- MODELS watchs ---------\n\n      $scope.$watch('VmAddEditCtrl.model.imageId', (value, oldValue) => {\n        if (value) {\n          const selectedSnapshot = _.find(self.panelsData.snapshots, { id: value });\n          // Set type: OS or Snapshot\n          self.model.imageType = selectedSnapshot ? 'SNAPSHOT' : 'IMAGE';\n\n          if (self.model.imageType === 'IMAGE') {\n            self.vmInEdition.image = _.find(self.panelsData.images, { id: value });\n            self.toggle.accordions.images = {};\n            if (self.vmInEdition.image.apps) {\n              self.toggle.accordions.images.apps = true;\n            } else {\n              self.toggle.accordions.images[self.vmInEdition.image.type] = true;\n            }\n\n            recalculateValues();\n          } else {\n            self.vmInEdition.image = selectedSnapshot;\n            // This snapshot is deleted\n            if (!self.vmInEdition.image) {\n              self.vmInEdition.image = {\n                id: value,\n                type: 'unknown',\n              };\n            }\n\n            self.toggle.accordions.images = {};\n            self.toggle.accordions.images.snapshots = true;\n\n            recalculateValues();\n          }\n\n          // reset ssh if windows\n          if (self.vmInEdition.image.type === 'windows') {\n            self.vmInEdition.sshKey = null;\n            self.model.sshKeyId = null;\n          }\n\n          // only allow install scripts for linux images\n          if (self.vmInEdition.image.type !== 'linux') {\n            self.vmInEdition.userData = null;\n          }\n\n          if (oldValue && value !== oldValue) {\n            self.backToMenu();\n          }\n        }\n      });\n\n      $scope.$watch('VmAddEditCtrl.model.region', (value, oldValue) => {\n        if (value) {\n          self.vmInEdition.region = value;\n          self.toggle.accordions.regions = {};\n          self.toggle.accordions.regions.public = true; // @todo\n\n\n          // recalculate display values\n          recalculateValues();\n          if (oldValue && value !== oldValue) {\n            self.backToMenu();\n          }\n\n          // if changing the region after a vlan has been picked\n          // keep it selected if also available in the new region\n          // select none if not available in the new region (silently and that ok...)\n          const network = _.find(\n            self.panelsData.privateNetworks,\n            network => network.id === self.vmInEdition.networkId, // eslint-disable-line\n          );\n\n          if (angular.isDefined(network)) {\n            if (!_.includes(_.map(network.regions, 'region'), value)) {\n              self.vmInEdition.networkId = undefined;\n            }\n          }\n        }\n      });\n\n      $scope.$watch('VmAddEditCtrl.model.sshKeyId', (value, oldValue) => {\n        if (value) {\n          const sshkey = _.find(self.panelsData.sshKeys, { id: value });\n          if (!sshkey || !sshkey.availableOnRegion) {\n            return;\n          }\n          self.vmInEdition.sshKey = sshkey;\n\n          if (value !== oldValue) {\n            self.backToMenu();\n          }\n        }\n      });\n\n      $scope.$watchCollection('VmAddEditCtrl.toggle.accordions.flavors', (value, oldValue) => {\n        if (value !== oldValue) {\n          const chosen = _.keys(_.pick(value, key => key));\n          if (chosen.length === 1) {\n            self.changeCategory(chosen[0]);\n          }\n        }\n      });\n\n      // ---\n\n      // --------- VM NAME ---------\n\n      self.canEditName = function () {\n        return self.loaders.allCompleted;\n      };\n\n      // cancel: true/false: force close if true\n      // ev: $event given by keyup\n      self.toggleEditVmName = function (cancel, ev) {\n        // If [escape], close name edition\n        if (ev) {\n          if (ev.keyCode === 27) {\n            ev.stopPropagation();\n            ev.preventDefault();\n          } else {\n            return;\n          }\n        }\n\n        // Save/Restore previous value\n        if (cancel) {\n          self.model.name = oldVmName;\n        } else {\n          oldVmName = self.model.name;\n        }\n\n        // moÃ©...\n        self.vmInEdition.name = self.model.name;\n\n        self.toggle.editVmName = !self.toggle.editVmName;\n\n        // Focus first elem\n        $timeout(() => {\n          $('.cloud-vm-popover').find(':tabbable:first').focus();\n        }, 99);\n      };\n\n      // --------- FLAVORS panel ---------\n\n      self.getFlavors = function () {\n        if (!self.loaders.panelsData.flavors) {\n          self.loaders.panelsData.flavors = true;\n\n          return $q.all([\n            OvhApiCloudProjectFlavor.v6().query({\n              serviceName,\n            }).$promise.then((flavorsList) => {\n              const modifiedFlavorsList = _.map(flavorsList, flavor => addDetailsToFlavor(flavor));\n\n              // Flavor types (ovh.ram, ovh.cpu, ...)\n              self.enums.flavorsTypes = _.uniq(_.pluck(modifiedFlavorsList, 'type'));\n\n              const flavorInList = _.find(\n                modifiedFlavorsList,\n                { id: self.vmInEdition.flavor && self.vmInEdition.flavor.id },\n              );\n\n              // if not in the list: it's a deprecated flavor: directly get it!\n              if (!flavorInList && self.vmInEdition.flavor && self.vmInEdition.flavor.id) {\n                return OvhApiCloudProjectFlavor.v6().get({\n                  serviceName,\n                  flavorId: self.vmInEdition.flavor.id,\n                }).$promise.then((flavorDeprecated) => {\n                  _.set(flavorDeprecated, 'deprecated', true);\n                  flavorsList.push(flavorDeprecated);\n                  self.panelsData.flavors = modifiedFlavorsList;\n                });\n              }\n              self.panelsData.flavors = modifiedFlavorsList;\n\n\n              if (!self.vmInEdition.flavor) { // this is a snapshot           to review\n                recalculateFlavor();\n              }\n              if (self.vmInEdition.status === 'ACTIVE') {\n                self.currentFlavor = addDetailsToFlavor(self.vmInEdition.flavor);\n              }\n\n              connectFlavorTogether();\n            }, (err) => {\n              CloudMessage.error([$translate.instant('cpcivm_addedit_flavor_error'), err.data.message || ''].join(' '));\n              return $q.reject(err);\n            }),\n            OvhApiCloudProjectQuota.v6().query({\n              serviceName,\n            }).$promise.then((quota) => {\n              self.panelsData.quota = quota;\n            }, (err) => {\n              CloudMessage.error([$translate.instant('cpcivm_addedit_quota_error'), err.data.message || ''].join(' '));\n              self.cancelVm();\n              return $q.reject(err);\n            }),\n            OvhCloudPriceHelper.getPrices(serviceName).then((flavorsPrices) => {\n              self.panelsData.prices = flavorsPrices;\n            }, (err) => {\n              CloudMessage.error([$translate.instant('cpcivm_addedit_flavor_price_error'), err.data.message || ''].join(' '));\n              return $q.reject(err);\n            }),\n            self.getImages(),\n            self.getSnapshots(),\n          ]).then(() => {\n            // Operations on flavors:\n            angular.forEach(self.panelsData.flavors, (flavor) => {\n              // add frequency\n              _.set(flavor, 'frequency', CLOUD_INSTANCE_CPU_FREQUENCY[flavor.type]);\n\n              // add price infos\n              const price = { price: { value: 0 }, monthlyPrice: { value: 0 } };\n              const planHourly = self.panelsData.prices[flavor.planCodes.hourly];\n              if (planHourly) {\n                price.price = planHourly.price;\n                // Set 3 digits for hourly price\n                price.price.text = price.price.text.replace(/\\d+(?:[.,]\\d+)?/, `${price.price.value.toFixed(3)}`);\n              }\n              const planMonthly = self.panelsData.prices[flavor.planCodes.monthly];\n              if (planMonthly) {\n                price.monthlyPrice = planMonthly.price;\n              }\n\n              _.set(flavor, 'price', price);\n              const currentFlavorUsage = {\n                vcpus: 0,\n                ram: 0,\n              };\n\n              // [EDITION] only:\n              if (self.vmInEdition.status === 'ACTIVE' && self.vmInEdition.saveForEdition && self.vmInEdition.saveForEdition.flavor && self.vmInEdition.saveForEdition.flavor.id) {\n                // set edited vm usage\n                currentFlavorUsage.vcpus = self.vmInEdition.saveForEdition.flavor.vcpus;\n                currentFlavorUsage.ram = self.vmInEdition.saveForEdition.flavor.ram;\n\n                // Disk: disable flavor if not enough space\n                if (self.currentFlavor.diskType === 'ssd' && flavor.diskType === 'ceph') {\n                  const ssdEquivalentFlavor = self.getFlavorOfType(flavor, 'ssd', false, flavor.region, flavor.osType);\n                  if (ssdEquivalentFlavor && ssdEquivalentFlavor.disk < self.currentFlavor.disk) {\n                    _.set(flavor, 'disabled', 'NOT_ENOUGH_SPACE');\n                  }\n                } else if (self.currentFlavor.diskType === 'ceph' && flavor.diskType === 'ssd') {\n                  const cephEquivalentFlavor = self.getFlavorOfType(flavor, 'ceph', false, flavor.region, flavor.osType);\n                  if (cephEquivalentFlavor && cephEquivalentFlavor.disk < self.currentFlavor.disk) {\n                    _.set(flavor, 'disabled', 'NOT_ENOUGH_SPACE');\n                  }\n                } else if (flavor.disk\n                  && flavor.disk < self.vmInEdition.saveForEdition.flavor.disk) {\n                  _.set(flavor, 'disabled', 'NOT_ENOUGH_SPACE');\n                }\n              }\n\n              // Disable flavors regarding of user's quota\n              const quotaOfFlavorRegion = _.find(self.panelsData.quota, { region: flavor.region });\n              if (quotaOfFlavorRegion && quotaOfFlavorRegion.instance) {\n                // Quota: Cores\n                if (flavor.vcpus\n                  && quotaOfFlavorRegion.instance.maxCores !== -1\n                  && (flavor.vcpus > (quotaOfFlavorRegion.instance.maxCores\n                    - (quotaOfFlavorRegion.instance.usedCores - currentFlavorUsage.vcpus)))) {\n                  _.set(flavor, 'disabled', 'QUOTA_VCPUS');\n                }\n                // Quota: RAM\n                if (flavor.ram\n                  && quotaOfFlavorRegion.instance.maxRam !== -1\n                  && (flavor.ram > (quotaOfFlavorRegion.instance.maxRam\n                    - (quotaOfFlavorRegion.instance.usedRAM - currentFlavorUsage.ram)))) {\n                  _.set(flavor, 'disabled', 'QUOTA_RAM');\n                }\n                // Quota: Instances\n                // We only check DRAFT status (creation) because editing an existing VM\n                // doest not create new instances\n                if (self.vmInEdition.status === 'DRAFT' && self.getRemainingInstanceQuota(flavor.region) <= 0) {\n                  _.set(flavor, 'disabled', 'QUOTA_INSTANCE');\n                }\n              }\n\n              // Edition only : check compatible flavors that can be selected\n              if (self.vmInEdition.status === 'ACTIVE' && self.vmInEdition.flavor && self.vmInEdition.flavor.type) {\n                if (!checkFlavorCompatibility(flavor, self.currentFlavor)) {\n                  _.set(flavor, 'incompatible', true);\n                }\n              }\n            });\n            // calculate windows licence price\n            const windowsFlavors = _.filter(self.panelsData.flavors, { osType: 'windows' });\n\n\n            const windowsLicences = _.filter(self.panelsData.images, { type: 'windows' }).concat(_.filter(self.panelsData.snapshots, { type: 'windows' }));\n\n\n            let associatedLinuxFlavor; let calculatedPriceValue; let\n              calculatedMonthlyPriceValue;\n\n            // set price to each windows licence\n            angular.forEach(windowsFlavors, (windowsFlavor) => {\n              associatedLinuxFlavor = _.find(self.panelsData.flavors, {\n                osType: 'linux',\n                region: windowsFlavor.region,\n                groupName: windowsFlavor.groupName,\n              });\n\n              if (associatedLinuxFlavor) {\n                // Put associated Linux Flavor into this Windows Flavor\n                _.set(windowsFlavor, 'associatedLinuxFlavor', associatedLinuxFlavor);\n\n                // For each Windows Image, add price diff for each flavor type\n                angular.forEach(windowsLicences, (windowsLicence) => {\n                  if (!windowsLicence.price) {\n                    _.set(windowsLicence, 'price', {});\n                  }\n                  if (!windowsFlavor.price || !associatedLinuxFlavor.price) {\n                    return;\n                  }\n\n                  // calculate licence additionnal price\n                  calculatedPriceValue = parseFloat((windowsFlavor.price.price.value\n                    - associatedLinuxFlavor.price.price.value).toFixed(3));\n                  calculatedMonthlyPriceValue = parseFloat((windowsFlavor.price.monthlyPrice.value\n                    - associatedLinuxFlavor.price.monthlyPrice.value).toFixed(2));\n                  // set windows licence additionnal price\n                  windowsLicence.price[windowsFlavor.groupName] = { // eslint-disable-line\n                    price: {\n                      currencyCode: associatedLinuxFlavor.price.price.currencyCode,\n                      text: `${calculatedPriceValue} ${associatedLinuxFlavor.price.price.currencyCode}`,\n                      value: calculatedPriceValue,\n                    },\n                    monthlyPrice: {\n                      currencyCode: associatedLinuxFlavor.price.monthlyPrice.currencyCode,\n                      text: `${calculatedMonthlyPriceValue} ${associatedLinuxFlavor.price.monthlyPrice.currencyCode}`,\n                      value: calculatedMonthlyPriceValue,\n                    },\n                  };\n                });\n              }\n            });\n            if (self.vmInEdition.isFlavorSuggested) {\n              firstTimeSetFlavor(true);\n            } else if (self.vmInEdition.status === 'ACTIVE' && self.vmInEdition.flavor && self.vmInEdition.flavor.type) {\n              firstTimeSetFlavor();\n            }\n          }, (err) => {\n            self.panelsData.flavors = null;\n            self.panelsData.prices = null;\n            return $q.reject(err);\n          }).finally(() => {\n            self.loaders.panelsData.flavors = false;\n          });\n        }\n      };\n\n      self.viewFlavorsList = function (orderBy, category) { // eslint-disable-line\n        self.toggle.editFlavor = 'flavors';\n        self.orderBy(orderBy, category, self.order.reverse);\n      };\n\n      self.orderBy = function (by, category, reverse) {\n        let filters = [];\n        self.order.by = by;\n        self.order.reverse = !!reverse;\n        switch (by) {\n          case 'vcpus':\n            filters = filters.concat(['vcpus', 'frequency', 'disk', 'ram']);\n            break;\n          case 'ram':\n            filters = filters.concat(['ram', 'disk', 'vcpus', 'frequency']);\n            break;\n          case 'price.price.value':\n            filters = filters.concat(['price.price.value', 'vcpus', 'frequency', 'disk']);\n            break;\n          case 'disk':\n            filters = filters.concat(['disk', 'vcpus', 'frequency']);\n            break;\n          default:\n            filters = filters.concat(['price.price.value', 'vcpus', 'frequency', 'disk']);\n            break;\n        }\n        const categoryObject = _.find(self.displayData.categories, { category });\n        categoryObject.flavors = orderBy(categoryObject.flavors, filters, self.order.reverse);\n      };\n\n\n      self.onMouseEnterFlavor = function () {\n        // Decorated function at runtime\n      };\n\n      self.selectFlavor = function (category, flavor) {\n        let realFlavor = self.getRealFlavor(flavor);\n\n        if (!realFlavor) {\n          realFlavor = flavor;\n        }\n\n        const changedDiskType = flavor.diskType !== realFlavor.diskType;\n\n        // If we're switching from ceph to ssd or ssd to ceph..\n        // we have to make sure the user is not downscaling.\n        let isDownscaling = false;\n        if (self.vmInEdition.status !== 'DRAFT' && realFlavor.disk < self.originalVm.flavor.disk) {\n          if (changedDiskType) {\n            isDownscaling = true;\n          } else {\n            // If it seems we are downscaling, we check the other disk type first\n            // to see if another option is available.\n            const otherDiskEquivalentFlavor = self.getFlavorOfType(flavor, realFlavor.diskType === 'ssd' ? 'ceph' : 'ssd', false, realFlavor.region, realFlavor.osType);\n            if (otherDiskEquivalentFlavor.disk >= self.originalVm.flavor.disk) {\n              self.model.diskType = otherDiskEquivalentFlavor.diskType;\n              realFlavor = otherDiskEquivalentFlavor;\n            }\n          }\n        }\n\n        if (!isDownscaling && _.isUndefined(realFlavor.disabled)) {\n          self.categoriesVmInEditionFlavor[category] = realFlavor;\n          self.displayData.shortGroupName = realFlavor.shortGroupName;\n          self.model.flavorId = realFlavor.id;\n          self.vmInEdition.flavor = realFlavor;\n          // set price of vmInEdition with price of flavor\n          self.vmInEdition.price = self.vmInEdition.flavor.price;\n          self.toggle.flavorDirty = true;\n          recalculateValues();\n          self.toggle.editFlavor = 'categories';\n        }\n      };\n\n      self.isIncompatible = function (category, diskType) {\n        // check disk compatibility\n        if (diskType) {\n          if (self.vmInEdition.status === 'ACTIVE') {\n            const augmentedFlavor = addDetailsToFlavor(self.originalVm.flavor);\n            // It should always be impossible to switch from an existing SSD instance\n            // to a ceph instance.\n            if (augmentedFlavor.diskType === 'ssd' && diskType === 'ceph') {\n              return true;\n            }\n\n            return augmentedFlavor.flex && augmentedFlavor.diskType === 'ceph';\n          }\n          const realFlavor = self.getFlavorOfCurrentRegionAndOSType(\n            self.categoriesVmInEditionFlavor[category],\n            diskType,\n            self.model.flex,\n          );\n          return !flavorIsValid(realFlavor);\n        }\n        // check if flex exists\n        const flexSsd = self.getFlavorOfCurrentRegionAndOSType(self.categoriesVmInEditionFlavor[category], 'ssd', true);\n        const flexCeph = self.getFlavorOfCurrentRegionAndOSType(self.categoriesVmInEditionFlavor[category], 'ceph', true);\n\n        // TODO: Refactor this to be more beautiful\n        if (self.vmInEdition.status === 'ACTIVE') {\n          if (self.model.diskType === 'ssd') {\n            if (flavorIsValid(flexSsd)) {\n              return self.currentFlavor\n                && (self.currentFlavor.flex === false && !self.currentFlavor.vps);\n            }\n            self.model.flex = false;\n            return true;\n          }\n          if (flavorIsValid(flexCeph)) {\n            return self.currentFlavor\n              && (self.currentFlavor.flex === false && !self.currentFlavor.vps);\n          }\n          self.model.flex = false;\n          return true;\n        }\n        if ((flavorIsValid(flexSsd)) && flavorIsValid(flexCeph)) {\n          return self.currentFlavor\n            && (self.currentFlavor.flex === false && !self.currentFlavor.vps);\n        }\n        self.model.flex = false;\n        return true;\n      };\n\n      self.selectDiskType = function (diskType, category) {\n        self.model.diskType = diskType;\n        self.selectFlavor(category, self.categoriesVmInEditionFlavor[category]);\n      };\n\n      self.hasGuaranteedRessources = function (flavorType) {\n        return _.find(CLOUD_INSTANCE_HAS_GUARANTEED_RESSOURCES, elem => elem === flavorType);\n      };\n\n      self.getRealFlavor = function (flavor, category) {\n        const osType = self.vmInEdition.image ? self.vmInEdition.image.type : 'linux';\n        const flex = category === 'accelerated' ? false : self.model.flex;\n        return self.getFlavorOfType(flavor, self.model.diskType, flex, self.model.region, osType);\n      };\n\n      self.getFlavorOfCurrentRegionAndOSType = function (flavor, diskType, flex) {\n        const osType = self.vmInEdition.image ? self.vmInEdition.image.type : 'linux';\n        return self.getFlavorOfType(flavor, diskType, flex, self.model.region, osType);\n      };\n\n      self.getFlavorOfType = function (flavor, diskType, flex, region, osType) {\n        if (flavor) {\n          if (flavor.vps) {\n            return flavor;\n          }\n          return _.find(\n            flavor.similarFlavors,\n            similarFlavor => similarFlavor.diskType === diskType\n              && similarFlavor.flex === flex\n              && similarFlavor.region === region\n              && similarFlavor.osType === osType,\n          );\n        }\n        return undefined;\n      };\n\n      function flavorIsValid(flavor) {\n        return flavor && !flavor.deprecated && !flavor.disabled && !flavor.incompatible;\n      }\n\n      function connectFlavorTogether() {\n        const flavorList = self.panelsData.flavors;\n        angular.forEach(self.panelsData.flavors, (flavor) => {\n          if (_.isUndefined(flavor.vps)) {\n            _.set(flavor, 'similarFlavors', _.filter(flavorList, flavorToCompare => flavor.shortGroupName === flavorToCompare.shortGroupName));\n          }\n        });\n      }\n\n      function addDetailsToFlavor(flavor) {\n        // Regex to get more info on flavor\n        const augmentedFlavor = flavor;\n        if (/vps/.test(flavor.type)) {\n          augmentedFlavor.vps = true;\n          augmentedFlavor.diskType = 'ssd';\n          augmentedFlavor.flex = false;\n          augmentedFlavor.shortGroupName = flavor.name;\n        } else {\n          let shortType;\n          let numberType;\n          if (flavor.osType === 'windows') {\n            shortType = _.first(_.rest(flavor.name.split('-')));\n            numberType = _.first(_.rest(_.rest(flavor.name.split('-'))));\n          } else {\n            shortType = _.first(flavor.name.split('-'));\n            numberType = _.first(_.rest(flavor.name.split('-')));\n          }\n          if (shortType) {\n            augmentedFlavor.shortType = shortType;\n          }\n          if (numberType) {\n            augmentedFlavor.numberType = numberType;\n          }\n          if (shortType && numberType) {\n            augmentedFlavor.shortGroupName = `${shortType}-${numberType}`;\n          }\n          augmentedFlavor.flex = /flex$/.test(flavor.name);\n          augmentedFlavor.diskType = /ssd/.test(flavor.type) ? 'ssd' : 'ceph';\n\n          if (_.indexOf(['g1', 'g2', 'g3'], augmentedFlavor.shortType) > -1) {\n            if (numberType === '120') {\n              augmentedFlavor.gpuCardCount = 3;\n            } else {\n              augmentedFlavor.gpuCardCount = 1;\n            }\n          }\n          augmentedFlavor.isOldFlavor = isOldFlavor(flavor.name);\n        }\n        return augmentedFlavor;\n      }\n\n      function isOldFlavor(flavorName) {\n        return /eg|sp|hg|vps-ssd/.test(flavorName);\n      }\n\n      function checkFlavorCompatibility(fromFlavor, toFlavor) {\n        return fromFlavor.diskType === toFlavor.diskType;\n      }\n\n\n      // --------- CATEGORIES panel ---------\n\n      self.isCurrentCategory = function (category) {\n        return !_.isEmpty(self.categoriesVmInEditionFlavor[category]);\n      };\n\n      self.changeCategory = function (category) {\n        if (_.isUndefined(self.categoriesVmInEditionFlavor[category])) {\n          // select the first VM of the category as the default (i.e: displayed info on the panel)\n          self.orderBy('vcpus', category);\n          self.categoriesVmInEditionFlavor[category] = {};\n        } else {\n          self.selectFlavor(category, self.categoriesVmInEditionFlavor[category]);\n          // we are in the same category as the current vm, current VM info will be displayed\n          // on the panel, nothing to do.\n        }\n        self.toggle.editFlavor = 'categories';\n      };\n\n      // --------- IMAGES+SNAPSHOTS panel ---------\n\n      self.getImages = function () {\n        if (!self.loaders.panelsData.images) {\n          self.loaders.panelsData.images = true;\n          return OvhApiCloudProjectImage.v6().query({\n            serviceName,\n          }).$promise.then((imagesList) => {\n            // Image types (linux, windows, ...)\n            self.enums.imagesTypes = _.uniq(_.pluck(imagesList, 'type'));\n            // [EDITION] only: restrict os type choice to current edited vm os type\n            // (windows if windows, linux if linux)\n            if (self.vmInEdition.status === 'ACTIVE' && self.vmInEdition.image) {\n              self.enums.imagesTypes = [self.vmInEdition.image.type];\n            }\n\n            // check if vm in edition image is in list. If not, push it in imagesList\n            const imageInList = _.find(\n              imagesList,\n              { id: self.vmInEdition.image && self.vmInEdition.image.id },\n            );\n\n            if (!imageInList && self.vmInEdition.image && self.vmInEdition.image.id && self.vmInEdition.image.visibility === 'public') {\n              return OvhApiCloudProjectImage.v6().get({\n                serviceName,\n                imageId: self.vmInEdition.image.id,\n              }).$promise.then((imageDeprecated) => {\n                _.set(imageDeprecated, 'deprecated', true);\n                imagesList.push(imageDeprecated);\n                self.panelsData.images = imagesList; // filter on public is already done\n              });\n            }\n            self.panelsData.images = imagesList; // filter on public is already done\n\n            self.panelsData.images = _.uniq(self.panelsData.images, 'id');\n            self.panelsData.images = _.map(\n              self.panelsData.images,\n              CloudImageService.constructor.augmentImage,\n            );\n          }).catch((err) => {\n            self.panelsData.images = null;\n            CloudMessage.error([$translate.instant('cpcivm_addedit_image_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.panelsData.images = false;\n          });\n        }\n      };\n\n      self.getSnapshots = function () {\n        if (!self.loaders.panelsData.snapshots) {\n          self.loaders.panelsData.snapshots = true;\n          return OvhApiCloudProjectSnapshot.v6().query({\n            serviceName,\n          }).$promise.then((snapshotList) => {\n            self.panelsData.snapshots = _.filter(snapshotList, { status: 'active' });\n\n            // [EDITION] only: restrict snapshots type choice to current edited vm snapshot type\n            // (windows if windows, linux if linux)\n            if (self.vmInEdition.status === 'ACTIVE' && self.vmInEdition.image) {\n              self.panelsData.snapshots = _.filter(\n                self.panelsData.snapshots,\n                { type: self.vmInEdition.image.type },\n              );\n            }\n          }, (err) => {\n            self.panelsData.snapshots = null;\n            CloudMessage.error([$translate.instant('cpcivm_addedit_image_snapshot_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.panelsData.snapshots = false;\n          });\n        }\n      };\n\n      function showImages(showAll, flavor) {\n        if (showAll) {\n          getDisplayImages();\n        } else if (flavor) {\n          getDisplayImages(flavor.shortType);\n        } else {\n          getDisplayImages();\n        }\n      }\n\n      function flavorHasSpecificImages(flavorShortType) {\n        return _.includes(CLOUD_FLAVOR_SPECIFIC_IMAGE, flavorShortType);\n      }\n\n      // --------- REGIONS panel ---------\n\n      self.getRegions = function () {\n        if (!self.loaders.panelsData.regions) {\n          self.loaders.panelsData.regions = true;\n\n          return OvhApiCloudProjectRegion.v6().query({\n            serviceName,\n          }).$promise.then((regionsList) => {\n            self.panelsData.regions = regionsList;\n          }, (err) => {\n            self.panelsData.regions = null;\n            CloudMessage.error([$translate.instant('cpcivm_addedit_image_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.panelsData.regions = false;\n          });\n        }\n      };\n\n      // --------- SSHKEYS panel ---------\n\n      self.getSshKeys = function (clearCache) {\n        if (!self.loaders.panelsData.sshKeys) {\n          self.loaders.panelsData.sshKeys = true;\n          if (clearCache) {\n            OvhApiCloudProjectSshKey.v6().resetQueryCache();\n          }\n          return OvhApiCloudProjectSshKey.v6().query({\n            serviceName,\n          }).$promise.then((sshList) => {\n            self.panelsData.sshKeys = sshList;\n            self.sshKeyDeletedId = null;\n\n            if (sshList.length === 0) {\n              self.toggleAddSshKey();\n            }\n            // get display ssh\n            getDisplaySshKeys();\n          }, (err) => {\n            self.panelsData.sshKeys = null;\n            CloudMessage.error([$translate.instant('cpcivm_addedit_sshkey_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.panelsData.sshKeys = false;\n          });\n        }\n      };\n\n      self.postSshKey = function () {\n        if (!self.loaders.sshKey.add) {\n          const uniq = _.find(\n            self.panelsData.sshKeys,\n            sshKey => sshKey.name === self.sshKeyAdd.name,\n          );\n\n          if (uniq) {\n            CloudMessage.info($translate.instant('cpcivm_addedit_sshkey_add_submit_name_error'));\n            return;\n          }\n\n          self.loaders.sshKey.add = true;\n          return OvhApiCloudProjectSshKey.v6().save({\n            serviceName,\n          }, {\n            name: self.sshKeyAdd.name,\n            publicKey: self.sshKeyAdd.publicKey,\n          }).$promise.then((newSshKey) => {\n            self.toggleAddSshKey();\n            return self.getSshKeys(true).then(() => {\n              self.model.sshKeyId = newSshKey.id;\n              CloudMessage.success($translate.instant('cpcivm_addedit_sshkey_add_submit_success'));\n            });\n          }, (err) => {\n            CloudMessage.error([$translate.instant('cpcivm_addedit_sshkey_add_submit_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.sshKey.add = false;\n          });\n        }\n      };\n\n      self.sshKeyAddRegion = function (sshKey) {\n        self.loaders.sshKey.add = true;\n        return OvhApiCloudProjectSshKey.v6().save({\n          serviceName,\n        }, {\n          name: sshKey.name,\n          publicKey: sshKey.publicKey,\n          region: self.model.region,\n        }).$promise.then(newSshKey => self.getSshKeys(true).then(() => {\n          self.model.sshKeyId = newSshKey.id;\n          CloudMessage.success($translate.instant('cpcivm_addedit_sshkey_add_submit_success'));\n        })).catch((err) => {\n          CloudMessage.error([$translate.instant('cpcivm_addedit_sshkey_add_submit_error'), err.data.message || ''].join(' '));\n        }).finally(() => {\n          self.loaders.sshKey.add = false;\n        });\n      };\n\n      self.deleteSshKey = function (keyId) {\n        if (!self.loaders.sshKey.remove) {\n          self.loaders.sshKey.remove = true;\n          return OvhApiCloudProjectSshKey.v6().remove({\n            serviceName,\n            keyId,\n          }).$promise.then(() => self.getSshKeys(true).then(() => {\n            if (keyId === self.model.sshKeyId) {\n              self.model.sshKeyId = null;\n            }\n            CloudMessage.success($translate.instant('cpcivm_addedit_sshkey_delete_success'));\n          }), (err) => {\n            CloudMessage.error([$translate.instant('cpcivm_addedit_sshkey_delete_error'), err.data.message || ''].join(' '));\n          }).finally(() => {\n            self.loaders.sshKey.remove = false;\n          });\n        }\n      };\n\n      self.toggleAddSshKey = function () {\n        if (self.toggle.openAddSshKey) {\n          initNewSshKey();\n        }\n        self.toggle.openAddSshKey = !self.toggle.openAddSshKey;\n      };\n\n      // return the maximum number of instances the user can create, for the choosen flavor\n      // regarding is remaining quota\n      self.getMaximumInstanceCreationCount = function () {\n        const flavor = _.find(self.panelsData.flavors, { id: self.model.flavorId });\n        const quota = _.find(self.panelsData.quota, { region: self.model.region });\n        let max = 0;\n        if (flavor && quota) {\n          max = quota.instance.maxInstances - quota.instance.usedInstances;\n          max = Math.min(max, Math.floor((quota.instance.maxCores - quota.instance.usedCores)\n            / flavor.vcpus));\n          max = Math.min(max, Math.floor((quota.instance.maxRam - quota.instance.usedRAM)\n            / flavor.ram));\n        }\n        return max;\n      };\n\n      // ---\n\n      self.fetchPublicNetworks = function () {\n        if (self.loaders.publicNetwork.query) {\n          return;\n        }\n\n        self.loaders.publicNetwork.query = true;\n\n        OvhApiCloudProjectNetworkPublic.v6().query({\n          serviceName,\n        }).$promise.then((networks) => {\n          self.panelsData.publicNetworks = networks;\n        }).catch((error) => {\n          self.panelsData.publicNetworks = [];\n          CloudMessage.error($translate.instant('cpcivm_addedit_advanced_options_public_network_query_error', {\n            message: JSON.stringify(error),\n          }));\n        }).finally(() => {\n          self.loaders.publicNetwork.query = false;\n        });\n      };\n\n      self.fetchPrivateNetworks = function () {\n        if (self.loaders.privateNetwork.query) {\n          return;\n        }\n\n        self.loaders.privateNetwork.query = true;\n\n        return OvhApiCloudProjectNetworkPrivate.v6().query({\n          serviceName,\n        }).$promise.then((networks) => {\n          self.panelsData.privateNetworks = networks;\n          return self.fetchPrivateNetworksSubnets();\n        }).catch((error) => {\n          self.panelsData.privateNetworks = [];\n          CloudMessage.error($translate.instant('cpcivm_addedit_advanced_options_private_network_query_error', {\n            message: JSON.stringify(error),\n          }));\n        }).finally(() => {\n          self.loaders.privateNetwork.query = false;\n        });\n      };\n\n      self.fetchPrivateNetworksSubnets = function () {\n        if (self.loaders.privateNetwork.subnet.query) {\n          return;\n        }\n\n        if (!self.panelsData.privateNetworks) {\n          return;\n        }\n\n        self.loaders.privateNetwork.subnet.query = true;\n\n        let networkIds = []; /* used to store an intermediate chain state. */\n\n        return _.chain(self.panelsData.privateNetworks)\n          .map(_.property('id'))\n          .tap((ids) => { networkIds = ids; })\n          .map(networkId => OvhApiCloudProjectNetworkPrivateSubnet.v6().query({\n            serviceName,\n            networkId,\n          }).$promise)\n          .thru((promises) => { /* .mapKeys on a more recent lodash. */\n            const collection = {};\n            _.forEach(promises, (promise, key) => {\n              collection[networkIds[key]] = promise;\n            });\n            return $q.all(collection);\n          })\n          .value()\n          .then((subnets) => {\n            self.panelsData.subnets = subnets;\n          })\n          .catch((error) => {\n            self.panelsData.subnets = [];\n            CloudMessage.error($translate.instant('cpcivm_addedit_advanced_options_private_network_subnet_query_error', {\n              message: error.data.message || JSON.stringify(error),\n            }));\n          })\n          .finally(() => {\n            self.loaders.privateNetwork.subnet.query = false;\n          });\n      };\n\n      self.getPrivateNetworks = function () {\n        const pad = Array(5).join('0');\n        return _.chain(self.panelsData.privateNetworks)\n          .filter((privateNetwork) => {\n            if (!_.has(self.panelsData.subnets, privateNetwork.id)) {\n              return false;\n            }\n            return _.some(privateNetwork.regions, 'region', self.model.region);\n          })\n          .sortBy('vlanId')\n          .map(network => _.assign(network, {\n            vlanId: pad.substring(0, pad.length - network.vlanId.toString().length)\n              + network.vlanId,\n          }))\n          .value();\n      };\n\n      self.hasVrackSupport = function () {\n        return self.states.hasVrack;\n      };\n\n      self.getVlansGuideUrl = function () {\n        return self.urls.vlansGuide;\n      };\n\n      self.getVlansApiGuideUrl = function () {\n        return self.urls.vlansApiGuide;\n      };\n\n      self.getVrackUrl = function () {\n        return self.urls.vrack;\n      };\n\n      self.getCreateSshKeysGuideUrl = function () {\n        return self.urls.guidesSshkeyURL;\n      };\n\n      // TODO : Delete this and the code in the .html once we remove the old catalog.\n      //        Used to display the proper label text.\n      self.catalogVersion = function () {\n        let oldCatalog = _.any(self.panelsData.regions, region => /GRA1|BHS1|SBG1/.test(region));\n        if (/(WAW)|(DE)|(UK)/.test(self.model.region)) {\n          oldCatalog = false;\n        }\n        return oldCatalog ? 'old' : 'new';\n      };\n\n      /**\n       * Check migration compatibility with Windows.\n       * @param  {String}   VPS category.\n       * @return {Boolean}  true if migration to this category of VPS is not possible\n       *                    because of Windows.\n       */\n      self.hasWindowsCompatibilityIssue = function (category) {\n        return self.vmInEdition.image && self.vmInEdition.image.type === 'windows' && category === 'vps';\n      };\n\n      self.showFlex = function (category) {\n        return _.includes(['balanced', 'cpu', 'ram'], category);\n      };\n\n      self.showCeph = function (category) {\n        return _.includes(['balanced', 'cpu', 'ram'], category) && self.getFlavorOfCurrentRegionAndOSType(self.categoriesVmInEditionFlavor[category], 'ceph', false) !== undefined;\n      };\n    });\n/* eslint-disable no-use-before-define, consistent-return */\n"]}